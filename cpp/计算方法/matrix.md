# matrix.h说明文档

[toc]

## 0.简要说明

这个模块是我用来处理矩阵的。。。因为想跟随的老师哪怕是STL库都不能使用，而C++原生提供的数组类型连数组的size都无法获取，这让我很苦恼。用惯了numpy的便捷，于是打算自己写一个用以科学计算的二维矩阵类型

之前想过要不要再写一个特殊的一维array类，后来仔细想了想，感觉这样重载的东西有点太多了，工作量比较大。而且matrix一个维度等于1就变成了array，于是我暂且不考虑array类。如果确实需要，或许我后面会加上





## 1.matrix类成员变量

1. m：矩阵行数，int类型
2. n：矩阵列数，int类型
3. p：指针，用于指向存储matrix变量的double类型指针

注意，上述均为public变量





## 2.matrix类成员函数

### 2.1.1.double**zeros2(int m,int n,double value=0.)分配二维内存函数

这个函数是唯二的private私有成员函数，用来对p指针分配内存

输入值为m，n和可选的value，返回的是一个指向m\*n数组的指针，且这个数组里的所有值为value，value默认为0

### 2.1.2.pn(int j,inti)代数余子式正负号

返回$(-1)^{i+j}$次方的结果

### 2.2.matrix(int m=1,int n=1,double value=0.)构造函数

为构造函数，构造一个m\*n的值全为value的matrix类型，默认情况下构造的是1\*1的0矩阵

### 2.3.matrix(const matrix &mat)拷贝构造函数

为拷贝构造函数，把mat这个matrix的全部信息拷贝给当前的matrix类

### 2.4.~matrix()析构函数

释放指针p的内存

### 2.5.+-*/!====^()重载运算符

这里比较难以解释，大概就是支持matrix间的加减乘除，和matrix与double数字的加减乘除，大概分为如下情况：

- 同样m,n的两个matrix相四则运算
- 一位数列加矩阵，为各行、各列相四则运算
- 数字与矩阵相四则运算，左右运算都可

如果维度对不上会在控制台抛出错误;返回值为运算完的矩阵类型matrix

ex：
```C++
matrix mat(3,3,300);
(3*mat).show();
```

输出结果:
```bash
900    900    900 
900    900    900 
900    900    900 
```

另外也对==和!=进行了重载，返回值为bool类型的值

```C++
std::cout<<mat==mat<<std::endl;
```

输出结果：
```bash
1
```

还对^进行了重载，需要注意的是是针对每个元素进行的运算，而非所有函数

更新：
对于()进行重载，mat(j,i)返回mat.p\[j\]\[i\]，可传入负数

对于\[\]进行重载，mat\[k\]按列索引，可传入负数

### 2.6.matrix Transpose()转置函数

返回当前矩阵的转置矩阵，为一个n\*m的矩阵

ex:

```C++
matrix mat(3,3,900);
mat.add(3); //列add 3
mat.add(1,'r'); //行add 1
mat.show();
(mat.Transpose()).show();
```

输出结果
```bash
900    900    900      1 
900    900    900      1 
900    900    900      1 
3      3      3      1 

900    900    900      3 
900    900    900      3 
900    900    900      3 
1      1      1      1 
```

### 2.7.void show()函数

将当前的矩阵打印在控制台上，前后空开一行，间隔为6字符

### 2.7.1.matrix dot(matrix mat2)点积函数

将当前的matrix乘以mat2，返回一个matrix结果；如果维度对不上将抛出错误

ex:

```C++
(mat.dot(mat)).show();
```

输出结果:
```bash
2.43e+06 2.43e+06 2.43e+06   2701 
2.43e+06 2.43e+06 2.43e+06   2701 
2.43e+06 2.43e+06 2.43e+06   2701 
  8103   8103   8103     10 
```

### 2.7.2.matrix power(int k)函数

得到矩阵的若干次方，该次方必须为整数，返回该矩阵

### 2.8.bool isSquare()判断方阵函数

判断当前矩阵是否为方阵，返回布尔值

ex:

```C++
std::cout<<mat.isSquare()<<std::endl;
```

输出结果:
```bash
1
```

### 2.9.matrix reshape(int m1,int n1)重塑函数

将m\*n的矩阵重塑为m1\*n1的矩阵，并将结果作为matrix返回，如果出现维度对不上会抛出错误

ex:

```C++
(mat.reshape(2,8)).show();
```

输出结果:
```bash
900    900    900      1    900    900    900      1 
900    900    900      1      3      3      3      1 
```

### 2.10.int add(double u,char layout) / int add(matrix mat2,char layout)增加函数

在原矩阵基础上增加项，增加项可谓double或者matrix类,运行正常时返回0

layout负责处理‘在列上增加’，‘在行上增加

- 在列上增加为，layout设为'c'，意为column
- 在行上增加为，layout设为'r'，意为row
- layout默认值为'c'

如果增加的matrix类维度不对，会报错；增加double类会将一行、一列全设为该值

ex:

```C++
matrix mat(3,3,900);
mat.add(3); //列add 3
mat.add(1,'r'); //行add 1
mat.show();
mat.add(mat,'r');
mat.show();
```

输出结果：
```bash
   900    900    900      1 
   900    900    900      1 
     3      3      3      1 

   900    900    900      1    900    900    900      1 
   900    900    900      1    900    900    900      1 
   900    900    900      1    900    900    900      1 
     3      3      3      1      3      3      3      1 
```

### 2.11.1.matrix cut(int j1=0,int j2=0,int i1=0,int i2=0)得到子矩阵函数

获得从j1~j2,i1~i2前闭后闭的子矩阵，取值分别为0~m-1和0~n-1，即真实索引

返回该子矩阵，用法如下:

ex:
```C++
    double a[5][4]={
        {1,2,3,4},
        {7,8,9,3},
        {3,2,1,3},
        {4,4,7,8},
        {8,9,10,7}
    };
    matrix mat=make_mat((double*)a,5,4);
    mat.show();
    mat.cut(0,3,0,2).show();
```

输出结果：
```bash
     1      2      3      4 
     7      8      9      3 
     3      2      1      3 
     4      4      7      8 
     8      9     10      7 

     1      2      3 
     7      8      9 
     3      2      1 
     4      4      7 
```

### 2.11.2.matrix row(int j)行矩阵

得到矩阵的j行，返回

### 2.11.3.matrix col(int i)列矩阵

得到矩阵的第i列,返回

### 2.11.4.void set_row(int j,matrix mat2)行矩阵赋值

给第j行赋值为mat2

### 2.11.5.void set_col(int i,matrix mat2)列矩阵赋值

给第i列赋值为mat2

### 2.11.6.void set_part(int j0,int i0,matrix mat2)部分赋值

以j0，i0为起点，把mat2覆盖到原矩阵的相应位置

### 2.12.matrix del(int j1,int i1)

删除j1行i1列，并返回扣除之后的矩阵，用法如下：

ex:

```C++
    double a[5][4]={
        {1,2,3,4},
        {7,8,9,3},
        {3,2,1,3},
        {4,4,7,8},
        {8,9,10,7}
    };
    matrix mat=make_mat((double*)a,5,4);
    mat.show();
    mat.cut(0,3,0,2).show();
    mat.del(3,1).show();
```

输出结果:

```bash
     1      2      3      4 
     7      8      9      3 
     3      2      1      3 
     4      4      7      8 
     8      9     10      7 

     1      2      3 
     7      8      9 
     3      2      1 
     4      4      7 

     1      3      4 
     7      9      3 
     3      1      3 
     8     10      7 
```


### 2.13.double det()行列式函数

返回double类型的行列式值，如果不是方阵会抛出错误；因为使用递归实现，所以性能可能不够高

ex:
```C++
    double a[4][4]={
        {1,2,3,4},
        {7,8,9,3},
        {3,2,1,3},
        {4,4,7,8},
    };
    matrix mat=make_mat((double*)a,4,4);
    mat.show();
    cout<<mat.det()<<endl;
```

输出结果:
```bash
     1      2      3      4 
     7      8      9      3 
     3      2      1      3 
     4      4      7      8 
138
```


### 2.14.matrix A()伴随矩阵函数

返回该矩阵的伴随矩阵，如不为方阵则抛出错误；调用了det()方法

ex:
```C++
    double a[4][4]={
        {1,2,3,4},
        {7,8,9,3},
        {3,2,1,3},
        {4,4,7,8},
    };
    matrix mat=make_mat((double*)a,4,4);
    mat.show();
    mat.A().show();
```

输出结果:
```bash
     1      2      3      4 
     7      8      9      3 
     3      2      1      3 
     4      4      7      8 

  -110     -2     26     46 
   148     19     29    -92 
   -56      4    -52     46 
    30    -12     18      0 
```


### 2.15.matrix inv()逆矩阵函数（终于写到你，还好我没放弃）

返回该矩阵的逆矩阵，因为算法非常老土，所以可能算出来会有极小量

ex:
```C++
    double a[4][4]={
        {1,2,3,4},
        {7,8,9,3},
        {3,2,1,3},
        {4,4,7,8},
    };
    matrix mat=make_mat((double*)a,4,4);
    mat.show();
    mat.inv().show();
    mat.dot(mat.inv()).show();
```

输出结果:
```bash
     1      2      3      4 
     7      8      9      3 
     3      2      1      3 
     4      4      7      8 

-0.797101 -0.0144928 0.188406 0.333333 
1.07246 0.137681 0.210145 -0.666667 
-0.405797 0.0289855 -0.376812 0.333333 
0.217391 -0.0869565 0.130435      0 

     1      0 -1.11022e-16      0 
6.66134e-16      1      0      0 
2.22045e-16      0      1 5.55112e-17 
2.22045e-16      0 -2.22045e-16      1 
```

### 2.16.1.matrix max(char layout='c')取最大函数

取最大值，返回取完之后的矩阵，默认按列取，返回行向量；选用'r'方法则按行取最大，返回列向量

ex:
```C++
    double a[4][4]={
        {1,10,3,4},
        {7,8,9,3},
        {3,2,100,3},
        {4,4,7,8},
    };
    matrix mat=make_mat((double*)a,4,4);
    mat.show();
    mat.max('r').show();
```

输出结果:
```bash
     1     10      3      4 
     7      8      9      3 
     3      2    100      3 
     4      4      7      8 

    10 
     9 
   100 
     8 
```

### 2.16.2.matrix min(char layout='c')取最小函数

用法同上


### 2.17.1.matrix sum(char layout='c')求和函数

按列求取，或者用'r'按行求取求和值并返回矩阵，用法同上

### 2.17.2.matrix prod(char layout='c')求积函数

按列求取，或者用'r'按行求取积并返回矩阵，用法同上



### 2.18.matrix mean(layout='c')求均值函数

按列求取，或者用'r'按行求取均值并返回矩阵，用法同上


### 2.19.void apply(double(*f)(double x))映射函数

对每一个元素作用f，并覆盖原矩阵



## 3.与其有关的函数

### 3.1.matrix eye(int n)单位构造矩阵

构造n维单位矩阵，返回matrix

ex:

```C++
eye(3).show();
```

输出结果：
```bash
     1      0      0 
     0      1      0 
     0      0      1 
```

### 3.2.matrix square(int n,double value=0.)方阵构造函数

用来生成一个全为value的n维方阵，返回该matrix

ex:
```C++
square(3,3,900).show();
```

输出结果:
```bash
   900    900    900 
   900    900    900 
   900    900    900 
```

### 3.3.matrix linspace(double beg,double en,double d,char layout='c')向量构造函数

构造以beg为起点，en为终点，d为步长的一维数组，并且默认是列向量；否则需要改layout='r'返回行向量；返回值为该matrix类

ex:
```C++
linspace(0,10,0.1,'r')show();
```

输出结果：
```bash
     0    0.1    0.2    0.3    0.4    0.5    0.6    0.7    0.8    0.9      1    1.1    1.2    1.3    1.4    1.5    1.6    1.7    1.8    1.9      2    2.1    2.2    2.3    2.4    2.5    2.6    2.7    2.8    2.9      3    3.1    3.2    3.3    3.4    3.5    3.6    3.7    3.8    3.9      4    4.1    4.2    4.3    4.4    4.5    4.6    4.7    4.8    4.9      5    5.1    5.2    5.3    5.4    5.5    5.6    5.7    5.8    5.9      6    6.1    6.2    6.3    6.4    6.5    6.6    6.7    6.8    6.9      7    7.1    7.2    7.3    7.4    7.5    7.6    7.7    7.8    7.9      8    8.1    8.2    8.3    8.4    8.5    8.6    8.7    8.8    8.9      9    9.1    9.2    9.3    9.4    9.5    9.6    9.7    9.8    9.9 
```

### 3.4.matrix arange(double beg,double en,int n,char layout='c')向量构造函数

构造以beg为起点，en为终点，n为份数的一维数组，并且默认是列向量；否则需要改layout='r'返回行向量；返回值为该matrix类

ex:
```C++
arange(0,10,100,'r')show();
```

输出结果：
```bash
     0    0.1    0.2    0.3    0.4    0.5    0.6    0.7    0.8    0.9      1    1.1    1.2    1.3    1.4    1.5    1.6    1.7    1.8    1.9      2    2.1    2.2    2.3    2.4    2.5    2.6    2.7    2.8    2.9      3    3.1    3.2    3.3    3.4    3.5    3.6    3.7    3.8    3.9      4    4.1    4.2    4.3    4.4    4.5    4.6    4.7    4.8    4.9      5    5.1    5.2    5.3    5.4    5.5    5.6    5.7    5.8    5.9      6    6.1    6.2    6.3    6.4    6.5    6.6    6.7    6.8    6.9      7    7.1    7.2    7.3    7.4    7.5    7.6    7.7    7.8    7.9      8    8.1    8.2    8.3    8.4    8.5    8.6    8.7    8.8    8.9      9    9.1    9.2    9.3    9.4    9.5    9.6    9.7    9.8    9.9 
```

### 3.5.matrix make_mat(double *p,int m,int n)构造矩阵函数

构造一个以数组为基础的矩阵，需要给出数组的行数列数，返回matrix类大致用法如下：

ex:
```C++
double a[5][4]={
        {1,2,3,4},
        {7,8,9,3},
        {3,2,1,3},
        {4,4,7,8},
        {8,9,10,7}
    };
matrix mat=make_mat((double*)a,5,4);
mat.show();
```

输出结果
```bash
     1      2      3      4 
     7      8      9      3 
     3      2      1      3 
     4      4      7      8 
     8      9     10      7 
```


### 3.6.1double max(matrix mat)取最大函数

将mat中最大值取出来并返回

ex:
```C++
    double a[4][4]={
        {1,10,3,4},
        {7,8,9,3},
        {3,2,100,3},
        {4,4,7,8},
    };
    matrix mat=make_mat((double*)a,4,4);
    mat.show();
    mat.max('r').show();
    cout<<max(mat)<<endl;
```

输出结果:
```bash
     1     10      3      4 
     7      8      9      3 
     3      2    100      3 
     4      4      7      8 

    10 
     9 
   100 
     8 
100
```

### 3.6.2.double min(matrix mat)取最小函数

用法同上


### 3.7.1.double sum(matrix mat)取和函数

返回所有的和

ex:
```C++
    double a[4][4]={
        {1,10,3,4},
        {7,8,9,3},
        {3,2,100,3},
        {4,4,7,8},
    };
    matrix mat=make_mat((double*)a,4,4);
    mat.show();
    mat.sum('r').show();
    cout<<sum(mat)<<endl;
    return 0;
}
```

输出结果：
```bash
     1     10      3      4 
     7      8      9      3 
     3      2    100      3 
     4      4      7      8 

    18 
    27 
   108 
    23 
176
```

### 3.7.2.double prod()求积函数

用法同上，返回所有的积


### 3.8.double mean()均值函数

返回整个矩阵的均值


### 3.9.matrix apply(matrix mat,double(*f)(double x))

对每一个mat里的元素作用f,并返回该矩阵

ex:
````C++
    double a[4][4]={
        {1,1,3,4},
        {7,1,1,3},
        {3,2,1,3},
        {1,1,7,8},
    };
    matrix mat=make_mat((double*)a,4,4);
    mat.show();
    apply(mat,f).show();
    mat.apply(f);
    mat.show();
```

输出结果:
```bash
     1      1      3      4 
     7      1      1      3 
     3      2      1      3 
     1      1      7      8 

     1      1      9     16 
    49      1      1      9 
     9      4      1      9 
     1      1     49     64 

     1      1      9     16 
    49      1      1      9 
     9      4      1      9 
     1      1     49     64 
```